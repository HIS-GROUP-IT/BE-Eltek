{"version":3,"sources":["../../../src/services/auth/auth.service.ts"],"sourcesContent":["import { hash, compare } from \"bcryptjs\";\r\nimport { sign } from \"jsonwebtoken\";\r\nimport { Service } from \"typedi\";\r\nimport { SECRET_KEY } from \"../../config\";\r\nimport { HttpException } from \"../../exceptions/HttpException\";\r\nimport crypto from \"crypto\";\r\nimport { AuthRepository } from \"@/repositories/auth/auth.repository\";\r\nimport { AUTH_SERVICE_TOKEN, IAuthService } from \"@/interfaces/auth/IAuthService.interface\";\r\nimport { DataStoreInToken, IUser, IUserLogin, TokenData } from \"@/types/auth.types\";\r\nimport nodemailer from \"nodemailer\";\r\nimport { Model } from \"sequelize\";\r\n\r\n\r\nconst createToken = async (userData: IUser): Promise<TokenData> => {\r\n    const dataStoredIntoken: DataStoreInToken = {\r\n        id: userData.id,\r\n        email: userData.email,\r\n        role : userData.role,\r\n        fullName : userData.fullName\r\n    };\r\n    const expiresAt = new Date();\r\n    expiresAt.setHours(expiresAt.getHours() + 1);\r\n\r\n    const accessToken = sign(dataStoredIntoken, SECRET_KEY, { expiresIn: \"1h\" });\r\n    const refreshToken = crypto.randomBytes(40).toString(\"hex\");\r\n    return { expiresAt, accessToken, refreshToken };\r\n}\r\n\r\n@Service({ id: AUTH_SERVICE_TOKEN, type: AuthService })\r\nexport class AuthService implements IAuthService {\r\n    constructor(public authRepository: AuthRepository) {}\r\n\r\n    public async signup(userData: IUser): Promise<TokenData> {\r\n        const findUser = await this.authRepository.findUserByEmail(userData.email);\r\n        if (findUser) {\r\n            throw new HttpException(409, `This email ${userData.email} already exists`);\r\n        }\r\n        const hashedPassword = await hash(userData.password, 10);\r\n        const createdUser = await this.authRepository.createUser({\r\n            email: userData.email,\r\n            password: hashedPassword,\r\n            role: userData.role,\r\n            fullName: userData.fullName\r\n        });\r\n        const tokenData = await createToken(createdUser);\r\n        await this.authRepository.saveRefreshToken(createdUser.id, tokenData.refreshToken, tokenData.expiresAt);\r\n        return tokenData;\r\n    }\r\n\r\n    public async login(userData: IUserLogin): Promise<TokenData> {\r\n      // Check if userData.password is provided\r\n      if (!userData.password) {\r\n          throw new HttpException(400, \"Password is required\");\r\n      }\r\n  \r\n      const findUser = await this.authRepository.findUserByEmail(userData.email);\r\n      console.log('User Data:', findUser); // Check if user data is correct and not undefined\r\n      if (!findUser) {\r\n          throw new HttpException(404, `Email ${userData.email} not found`);\r\n      }\r\n  \r\n      console.log('Raw user data:', JSON.stringify(findUser));\r\n      console.log('Is Sequelize instance:', findUser instanceof Model);\r\n  \r\n      // Ensure that the password is a valid string\r\n      if (!findUser.password) {\r\n          throw new HttpException(404, \"User password not found in database\");\r\n      }\r\n  \r\n      const comparePassword = await compare(userData.password, findUser.password);\r\n      if (!comparePassword) {\r\n          throw new HttpException(400, \"Invalid password\");\r\n      }\r\n  \r\n      const tokenData = await createToken(findUser);\r\n      console.log('Token Data:', tokenData); // Check if tokenData is correct and not undefined\r\n  \r\n      // Save refresh token\r\n      await this.authRepository.saveRefreshToken(findUser.id, tokenData.refreshToken, tokenData.expiresAt);\r\n      return tokenData;\r\n  }\r\n\r\n    public async refreshToken(token: string): Promise<TokenData> {\r\n        if (!token) {\r\n            throw new HttpException(404, \"Token not provided\");\r\n        }\r\n\r\n        const storedToken = await this.authRepository.findRefreshToken(token);\r\n        if (!storedToken || storedToken.expiresAt < new Date()) {\r\n            throw new HttpException(401, \"Invalid or expired token\");\r\n        }\r\n\r\n        const user = await this.authRepository.findUserById(storedToken.userId);\r\n        if (!user) {\r\n            throw new HttpException(404, `User associated with this token not found`);\r\n        }\r\n\r\n        const newToken = await createToken(user);\r\n        await this.authRepository.deleteRefreshToken(storedToken.token);\r\n        await this.authRepository.saveRefreshToken(user.id, newToken.refreshToken, newToken.expiresAt);\r\n        return newToken;\r\n    }\r\n\r\n    public async logout(token: string): Promise<void> {\r\n        await this.authRepository.deleteRefreshToken(token);\r\n    }\r\n\r\n    public async sendOtp(email: string): Promise<string> {\r\n        const user = await this.authRepository.findUserByEmail(email);\r\n        if (!user) {\r\n          throw new HttpException(404, \"User Not Found\");\r\n        }\r\n        const otp = Math.floor(100000 + Math.random() * 900000).toString();\r\n        await this.authRepository.saveOtp(email, otp);\r\n        const transporter = nodemailer.createTransport({\r\n          host: process.env.EMAIL_HOST,\r\n          port: process.env.EMAIL_PORT,\r\n          secure: false,\r\n          auth: {\r\n            user: process.env.EMAIL_USER,\r\n            pass: process.env.EMAIL_PASS,\r\n          },\r\n        });    \r\n        const mailOptions = {\r\n          from: process.env.EMAIL_USER,\r\n          to: email,\r\n          subject: \"Password Reset OTP\",\r\n          html: `<p>Your OTP to reset your password is <strong>${otp}</strong></p>`,\r\n        };    \r\n        await transporter.sendMail(mailOptions);    \r\n        return \"OTP sent to your email\";\r\n      }\r\n\r\n  public async verifyOtp(email: string, otp: string): Promise<string> {\r\n    const isValid = await this.authRepository.validateOtp(email, otp);\r\n\r\n    if (!isValid) {\r\n      throw new HttpException(400, \"Invalid or expired OTP\");\r\n    }\r\n\r\n    return \"OTP verified successfully\";\r\n  }\r\n\r\n  public async updatePassword(email: string, otp: string, newPassword: string): Promise<IUser> {\r\n    const user = await this.authRepository.findUserByEmail(email);\r\n    if (!user) {\r\n      throw new HttpException(404, \"User Not Found\");\r\n    }\r\n    if (user.otp !== otp) {\r\n      throw new HttpException(400, \"Invalid OTP\");\r\n    }\r\n    const updatedUser = await this.authRepository.forgotPassword(email, otp, newPassword);\r\n    return updatedUser;\r\n  }\r\n    \r\n}\r\n"],"names":["AuthService","createToken","userData","dataStoredIntoken","id","email","role","fullName","expiresAt","Date","setHours","getHours","accessToken","sign","SECRET_KEY","expiresIn","refreshToken","crypto","randomBytes","toString","signup","findUser","authRepository","findUserByEmail","HttpException","hashedPassword","hash","password","createdUser","createUser","tokenData","saveRefreshToken","login","console","log","JSON","stringify","Model","comparePassword","compare","token","storedToken","findRefreshToken","user","findUserById","userId","newToken","deleteRefreshToken","logout","sendOtp","otp","Math","floor","random","saveOtp","transporter","nodemailer","createTransport","host","process","env","EMAIL_HOST","port","EMAIL_PORT","secure","auth","EMAIL_USER","pass","EMAIL_PASS","mailOptions","from","to","subject","html","sendMail","verifyOtp","isValid","validateOtp","updatePassword","newPassword","updatedUser","forgotPassword","constructor","AUTH_SERVICE_TOKEN","type"],"mappings":"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"}